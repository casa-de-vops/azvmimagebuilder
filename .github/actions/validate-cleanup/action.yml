name: "Validate and Cleanup"
description: "Validates a custom VM image and cleans up resources"

inputs:
  sig-resource-group:
    required: true
    description: "The resource group for the Shared Image Gallery"
  template-type:
    required: true
    description: "The template type (armTemplate or imageTemplate)"
  image-template-name:
    required: true
    description: "The image template name"
  primary-region:
    required: true
    description: "The primary region for image distribution"
  subscription-id:
    required: true
    description: "Azure subscription ID"
  sig-name:
    required: true
    description: "The Shared Image Gallery name"
  image-def-name:
    required: true
    description: "The image definition name"
  validation-vm-name:
    required: true
    description: "The name for the validation VM"
  validation-rg:
    required: true
    description: "The resource group for validation"
  build-rg-name:
    required: false
    description: "The build resource group name, if specified will use this instead of creating a new validation RG"
    default: ""
  skip-distribution-wait:
    required: false
    description: "If true, skips waiting for image distribution to complete, useful when validating existing images"
    default: false

runs:
  using: "composite"
  steps:
    # ── Wait for image distribution to complete ──────────────────
    - name: Wait for image distribution to complete
      if: inputs.skip-distribution-wait != 'true'
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'
        Write-Host "Waiting for image distribution to complete..."

        # Wait for the image distribution to finish (checking template status)
        $maxRetries = 60  # 30 minutes (checking every 30 seconds)
        $retryCount = 0
        $success = $false

        do {
          $retryCount++
          $res = Get-AzResource `
            -ResourceGroupName "${{ inputs.sig-resource-group }}" `
            -ResourceType 'Microsoft.VirtualMachineImages/imageTemplates' `
            -Name "${{ inputs.image-template-name }}" `
            -ErrorAction SilentlyContinue
          
          if ($res -and $res.Properties.lastRunStatus) {
            $status = $res.Properties.lastRunStatus
            Write-Host "[$retryCount/$maxRetries] Image status: $($status.runState) → $($status.runSubState)"
            
            if ($status.runState -eq 'Succeeded') {
              $success = $true
              break
            }
            elseif ($status.runState -eq 'Failed' -or $status.runState -eq 'Canceled') {
              Write-Host "Image creation failed with status: $($status.runState)"
              Write-Host "Error: $($status.message)"
              exit 1
            }
          }
          else {
            Write-Host "[$retryCount/$maxRetries] Waiting for image template status..."
          }
          
          Start-Sleep -Seconds 30
        } while ($retryCount -lt $maxRetries)

        if (-not $success) {
          Write-Host "Timed out waiting for image distribution to complete!"
          exit 1
        }

        Write-Host "Image distribution completed successfully!"

    # ── Create resource group for validation VM ─────────────────
    - name: Create validation resource group
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'

        # Check if we should use the build RG instead of creating a new one
        if ([string]::IsNullOrEmpty('${{ inputs.build-rg-name }}')) {
          Write-Host "Creating new validation resource group: ${{ inputs.validation-rg }}"
          New-AzResourceGroup -Name "${{ inputs.validation-rg }}" -Location "${{ inputs.primary-region }}" -Force
        } else {
          Write-Host "Using existing build resource group for validation: ${{ inputs.build-rg-name }}"
          # Validate that the resource group exists
          Get-AzResourceGroup -Name "${{ inputs.validation-rg }}" -ErrorAction Stop | Out-Null
        }

        Write-Host "Using validation resource group: ${{ inputs.validation-rg }}"

    # ── Deploy validation VM using the new image ────────────────
    - name: Deploy validation VM
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'

        # Get the latest image version
        $imageId = (Get-AzGalleryImageVersion -ResourceGroupName "${{ inputs.sig-resource-group }}" -GalleryName "${{ inputs.sig-name }}" -GalleryImageDefinitionName "${{ inputs.image-def-name }}" | 
          Sort-Object -Property PublishingProfile.PublishedDate -Descending | 
          Select-Object -First 1).Id
          
        if (-not $imageId) {
          Write-Host "Could not find image in gallery. Validation failed."
          exit 1
        }

        Write-Host "Found image ID: $imageId"

        # Generate a random password for the VM
        $adminPassword = [System.Guid]::NewGuid().ToString() + "aA1!"
        $adminPasswordSecure = ConvertTo-SecureString $adminPassword -AsPlainText -Force
          # Deploy validation VM
        $vmParams = @{
          ResourceGroupName = "${{ inputs.validation-rg }}"
          Name = "${{ inputs.validation-vm-name }}"
          Location = "${{ inputs.primary-region }}"
          Credential = New-Object System.Management.Automation.PSCredential ("azureuser", $adminPasswordSecure)
          Size = "Standard_D2s_v3"
          SecurityType = "Standard"
          PublicIpAddressName = "${{ inputs.validation-vm-name }}-pip"
          OpenPorts = 3389
        }
        
        Write-Host "Deploying validation VM..."
        
        # Use the -Image parameter directly instead of ImageId
        $vm = New-AzVM @vmParams -Image $imageId

        Write-Host "VM deployment completed. Waiting for VM to be ready..."

        # Wait for VM to be ready
        Start-Sleep -Seconds 60

        # Check VM status
        $vmStatus = (Get-AzVM -ResourceGroupName "${{ inputs.validation-rg }}" -Name "${{ inputs.validation-vm-name }}" -Status).Statuses | 
          Where-Object { $_.Code -like "PowerState/*" } | 
          Select-Object -ExpandProperty DisplayStatus
          
        Write-Host "VM Status: $vmStatus"

        if ($vmStatus -ne "VM running") {
          Write-Host "VM is not running. Validation failed."
          exit 1
        }

        Write-Host "Validation VM deployed and running successfully!"

    # ── Run basic validation tests on VM ───────────────────────
    - name: Run validation tests
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'

        # We'll use a simple test to verify the VM is responsive
        $vmStatus = Get-AzVM -ResourceGroupName "${{ inputs.validation-rg }}" -Name "${{ inputs.validation-vm-name }}" -Status
        $bootStatus = $vmStatus.Statuses | Where-Object { $_.Code -eq "OSState/generalized" -or $_.Code -eq "OSState/specialized" }

        if ($bootStatus.DisplayStatus -eq "OS state is specialized") {
          Write-Host "✅ VM is properly specialized (not generalized)"
        } else {
          Write-Host "❌ VM is not in the expected state. Found: $($bootStatus.DisplayStatus)"
          exit 1
        }

        Write-Host "✅ Validation tests passed!"

        # Add to summary
        Write-Output "### Validation Results" | Out-File -Append $env:GITHUB_STEP_SUMMARY
        Write-Output "* Validation VM: **${{ inputs.validation-vm-name }}**" | Out-File -Append $env:GITHUB_STEP_SUMMARY
        Write-Output "* VM Status: **Running**" | Out-File -Append $env:GITHUB_STEP_SUMMARY
        Write-Output "* Validation Result: **✅ Success**" | Out-File -Append $env:GITHUB_STEP_SUMMARY

    # ── Cleanup resources ─────────────────────────────────────
    - name: Cleanup resources
      if: always()
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Continue' # Don't exit on error during cleanup
        
        Write-Host "Cleaning up resources..."

        # Delete validation VM
        try {
          Write-Host "Deleting validation VM: ${{ inputs.validation-vm-name }}"
          Remove-AzVM -ResourceGroupName "${{ inputs.validation-rg }}" -Name "${{ inputs.validation-vm-name }}" -Force
        } catch {
          Write-Host "Error deleting VM ${{ inputs.validation-vm-name }}: $_"
        }

        # Wait for the VM deletion to complete before proceeding
        Start-Sleep -Seconds 30

        # Delete the VM's resources in the correct order - first get all resources
        $resources = Get-AzResource -ResourceGroupName "${{ inputs.validation-rg }}" | Where-Object {
          $_.Name -like "${{ inputs.validation-vm-name }}*" -and 
          ($_.ResourceType -eq "Microsoft.Compute/disks" -or 
           $_.ResourceType -eq "Microsoft.Network/networkInterfaces" -or
           $_.ResourceType -eq "Microsoft.Network/publicIPAddresses")
        }
        
        # First delete network interfaces
        $nics = $resources | Where-Object { $_.ResourceType -eq "Microsoft.Network/networkInterfaces" }
        foreach ($nic in $nics) {
          try {
            Write-Host "Deleting resource: $($nic.Name)"
            Remove-AzResource -ResourceId $nic.ResourceId -Force
          } catch {
            Write-Host "Error deleting NIC $($nic.Name): $_"
          }
        }
        
        # Wait a bit for the NICs to be fully deleted
        Start-Sleep -Seconds 30
        
        # Then delete public IPs
        $pips = $resources | Where-Object { $_.ResourceType -eq "Microsoft.Network/publicIPAddresses" }
        foreach ($pip in $pips) {
          try {
            Write-Host "Deleting resource: $($pip.Name)"
            Remove-AzResource -ResourceId $pip.ResourceId -Force
          } catch {
            Write-Host "Error deleting Public IP $($pip.Name): $_"
          }
        }
        
        # Wait for public IPs to be fully deleted
        Start-Sleep -Seconds 30
        
        # Finally delete disks
        $disks = $resources | Where-Object { $_.ResourceType -eq "Microsoft.Compute/disks" }
        foreach ($disk in $disks) {
          try {
            Write-Host "Deleting resource: $($disk.Name)"
            Remove-AzResource -ResourceId $disk.ResourceId -Force          } catch {
            Write-Host "Error deleting disk $($disk.Name): $_"
          }
        }
        
        # Only delete the resource group if it's a temporary validation group
        if ([string]::IsNullOrEmpty('${{ inputs.build-rg-name }}')) {
          Write-Host "Deleting validation resource group: ${{ inputs.validation-rg }}"
          Remove-AzResourceGroup -Name "${{ inputs.validation-rg }}" -Force -AsJob
        } else {
          Write-Host "Keeping build resource group: ${{ inputs.validation-rg }} (as requested)"
        }

        # Delete the image template if one was specified
        if (-not [string]::IsNullOrEmpty('${{ inputs.image-template-name }}')) {
          Write-Host "Deleting image template: ${{ inputs.image-template-name }}"
          Remove-AzResource `
            -ResourceGroupName "${{ inputs.sig-resource-group }}" `
            -ResourceType "Microsoft.VirtualMachineImages/imageTemplates" `
            -Name "${{ inputs.image-template-name }}" `
            -Force
        } else {
          Write-Host "No image template was specified, skipping template cleanup"
        }
